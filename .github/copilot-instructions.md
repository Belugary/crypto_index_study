<!-- Copilot 自动化开发指南 -->

# 区块链资产指数研究项目开发指南

本指南为 AI 助手提供项目开发的核心原则、工作流和资产管理规范。

---

## 1. 项目核心原则

### 1.1. 项目目标

- **核心目的**: 区块链资产指数研究与量化分析。
- **技术栈**: Python, CoinGecko API**案例：参数设计错误**

- **第一层 (表象)**: 为什么原生币数量不足？
  - **答案**: 因为搜索范围被限制在用户指定的数值内。
- **第二层 (直接原因)**: 为什么会限制搜索范围？
  - **答案**: 因为将用户参数误解为"搜索限制"而非"目标结果"。
- **第三层 (深层原因)**: 为什么会误解参数含义？
  - **答案**: 因为缺乏用户需求的深入理解，按技术实现思维设计接口。
- **第四层 (哲学原因)**: 为什么不以用户视角思考？
  - **答案**: 因为存在"技术优先"的思维惯性，认为实现逻辑比用户体验更重要。
- **第五层 (根本原因)**: 为什么会追求技术复杂性？
  - **答案**: **设计哲学偏差**。违背了"用户导向"的核心原则，陷入了对技术实现的盲目关注。 **数据源**: CoinGecko Pro API (通过 `.env` 文件配置)。

### 1.2. API 使用

- **分类**: 基础 (🔹), Premium (💼), Analyst (👑)。
- **规范**: 使用 `requests.Session()` 复用连接，所有方法需包含详细参数说明和错误处理。

---

## 2. 开发工作流

### 2.1. 代码风格

- **注释与文档**: 使用中文注释和详细的类型提示。
- **用户提示**: API 调用前后需有明确的状态提示信息。

### 2.2. 测试要求

- **位置**: 所有测试文件必须放在 `tests/` 目录。
- **内容**: 每个新增的 API 功能都应有对应的测试，并包含清晰的成功/失败总结。

---

## 3. 配置一致性原则 (重要)

### 3.1. 核心配置参数

**数据范围**: 支持灵活的原生币目标数量配置（默认 510 个），系统通过动态搜索范围扩展确保目标达成

**重要原则**: 用户参数应作为**目标结果**而非搜索限制，系统需自动调整内部逻辑实现目标

### 3.2. 一致性检查清单

任何涉及数据范围或核心配置的修改，必须检查以下位置的一致性：

1. **代码层面**:

   - `scripts/update_price_data.py` 中所有默认参数值
   - `main.py` 中的示例和说明文本
   - 函数签名中的默认值 (如 `target_native_coins=510`)
   - 帮助文档字符串和命令行参数描述

2. **文档层面**:

   - `README.md` 中的功能描述和数据范围说明
   - `.github/copilot-instructions.md` 中的数据资产范围
   - 任何包含数值的表格、列表或示例

3. **配置层面**:
   - 所有脚本的命令行参数默认值
   - 配置文件中的相关设置
   - 测试文件中的期望值 (虽然测试可用小数据集)

### 3.3. 防范措施

- **单一数据源原则**: 所有关键配置应有唯一的定义源，其他地方引用而非重复定义
- **修改前检查**: 任何数值修改前，使用 `grep_search` 工具搜索项目中所有相关出现
- **批量验证**: 修改后运行完整测试套件，确保所有功能正常
- **文档同步**: 代码修改后立即更新所有相关文档

---

## 4. 资产管理

### 4.1. 数据资产 (核心)

- **范围**: 市值前 600 名币种的日级别历史量价数据，支持灵活配置原生币目标数量（默认 510 个）。
- **配置**: 通过 `--native-coins` 参数支持自定义目标原生币数量，系统自动扩展搜索范围直到达成目标。
- **过滤**: 自动识别并可选择排除稳定币 (80 个) 和包装币 (24 个)。
- **更新规范**:
  1. **README**: 必须更新 `(最近更新: YYYY-MM-DD)`。
  2. **Git 提交**: 必须使用 `📊 数据更新: ...` 格式。
  3. **质量**: 定期检查数据完整性、质量和一致性。

### 4.2. 文件系统

- **核心原则**: 保持简洁，避免临时文件，所有文件都应有明确的长期价值。
- **目录结构**:
  ```
  src/         # 核心功能代码
  scripts/     # 自动化脚本
  examples/    # 使用示例
  tests/       # 测试代码
  data/        # 数据资产 (coins/, metadata/)
    ├── coins/         # 币种历史价格数据
    ├── metadata/      # 元数据文件
    │   ├── native_coins.csv    # 原生币清单
    │   ├── stablecoins.csv     # 稳定币清单
    │   └── wrapped_coins.csv   # 包装币清单
    └── daily/         # 日级别聚合数据
  logs/        # 日志文件
  ```
- **日志管理**:
  - 所有日志统一存放在根目录的 `logs/` 中。
  - `.gitignore` 已配置忽略本地日志文件。
- **禁止的文件**:
  - 根目录禁止创建任何 `test_*.py`, `temp_*.py`, `debug_*.py` 等临时脚本。
  - 避免创建功能重复的文件。

### 4.3. 文档管理

- **核心文档**:
  - `README.md`: 用户使用指南。
  - `CHANGELOG.md`: 版本更新日志。
  - `.github/copilot-instructions.md`: AI 开发指南。
- **更新原则**:
  - **同步性**: 代码更新后，必须同步更新所有相关文档。
  - **一致性**: 所有文档中的功能描述、路径引用和数据范围必须保持一致。
  - **简洁性**: 避免冗余和过度工程化的文档。
- **质量检查**: 更新后需检查路径引用、数据描述和时间戳是否正确。

### 4.4. Agent 上下文管理 (Context Management)

- **核心原则**: 严格控制上下文大小，避免引用 `data/` 目录下的海量数据文件 (如 `coins/*.csv`, `metadata/coin_metadata/*.json`)，以节省 Token 并提高效率。
- **执行细则**:
  - **Git 状态总结**: 在检查 `git status` 或 `get_changed_files` 时，如果发现大量 `data/` 目录下的文件变更，**必须**进行总结性描述（例如：“发现 N 个新的元数据文件”），**严禁**在响应中逐一列出文件内容或 diff。
  - **主动忽略**: 除非用户明确要求操作或查询 `data/` 目录下的具体文件内容，否则在常规代码修改、测试、分析任务中应主动忽略此目录。
  - **聚焦核心代码**: 在进行全工作区搜索或分析时，应优先聚焦于 `src/`, `scripts/`, `tests/` 等核心代码目录。

---

## 5. 变更管理最佳实践

### 5.1. 配置变更流程

1. **影响评估**: 使用 `grep_search` 全项目搜索相关配置
2. **批量更新**: 一次性更新所有相关位置，避免遗漏
3. **测试验证**: 运行完整测试套件确保功能正常
4. **文档同步**: 立即更新所有相关文档
5. **一致性检查**: 再次搜索确认无遗漏

### 5.2. 代码质量守则

- **参数传递**: 优先使用参数传递而非硬编码常量
- **配置中心化**: 重要配置集中定义，避免分散重复
- **依赖注入**: 支持测试和生产环境的不同配置
- **向后兼容**: 新功能不破坏现有接口

### 5.3. 错误防范

- **强制检查**: 任何数值修改都必须进行全项目一致性检查
- **自动化测试**: 关键配置变更必须有测试覆盖
- **版本控制**: 重要变更前创建分支，便于回滚
- **文档审查**: 变更后必须检查所有相关文档是否同步更新

### 5.4. 深层架构原则

- **单一职责**: 每个配置参数应有明确的唯一定义源
- **可测试性**: 所有配置都应支持依赖注入以便测试
- **可维护性**: 配置变更应有明确的影响范围和变更流程
- **可追溯性**: 配置变更必须有完整的文档记录和测试验证

---

## 6. 深层根因分析与哲学原则 (新增)

### 6.1. 多层级反思 (五问法)

在解决问题时，必须超越表面现象，通过连续追问“为什么”来探究根本原因。

**案例：数据分类错误**

- **第一层 (表象)**: 为什么原生币数量不足？
  - **答案**: 因为稳定币和包装币被过度分类，排除了过多的原生币。
- **第二层 (直接原因)**: 为什么会过度分类？
  - **答案**: 因为分类逻辑过于复杂，使用了宽泛的自定义关键词匹配。
- **第三层 (深层原因)**: 为什么会使用复杂的自定义逻辑？
  - **答案**: 因为不信任官方数据源的权威性，试图“做得更全面”。
- **第四层 (哲学原因)**: 为什么不信任权威数据源？
  - **答案**: 因为存在“过度工程化”的思维惯性，认为复杂的方案优于简单的方案。
- **第五层 (根本原因)**: 为什么会追求复杂性？
  - **答案**: **工程哲学偏差**。违背了“简单有效”的核心原则，陷入了对复杂性的盲目追求。

### 6.2. 核心开发哲学

为从根本上规避此类问题，项目必须遵循以下哲学：

1.  **简单胜于复杂 (Simplicity First)**:

    - **Python 之禅**: 遵循 `import this` 的精神。优先选择最简单、直接且有效的解决方案。
    - **奥卡姆剃刀**: 如无必要，勿增实体。不要增加不必要的复杂性。

2.  **信任权威数据源 (Authoritative Source Priority)**:

    - **官方标准优先**: CoinGecko 的官方分类标签是第一权威，自定义逻辑只能作为补充且需严格审查。
    - **避免重复发明**: 不要试图重新实现已有标准能够解决的问题。

3.  **用户导向设计 (User-Centric Design)**:
    - **目标优先**: 用户参数应表达期望的结果，系统负责实现这个目标。
    - **体验至上**: 接口设计应符合用户直觉，而非暴露技术实现细节。

### 6.3. 可执行的预防措施

1.  **设计决策清单**:

    - **三问机制**: 每个重要技术决策前，必须回答三个“为什么”。
    - **简单性验证**: 能否用一句话向非技术人员解释清楚这个设计？如果不能，它可能太复杂了。
    - **权威性检查**: 是否存在可以直接使用的行业标准或官方定义？

2.  **代码审查标准**:
    - **Python 之禅检查**: 代码是否体现了“优美”、“明确”、“简单”的特质？
    - **复杂性告警**: 一个函数或方法中的 `if/else` 嵌套超过 3 层，或条件判断超过 5 个，应被视为“代码异味”，需要重新设计。
    - **依赖检查**: 是否优先依赖了官方或权威的字段/接口，而非自定义的解析逻辑？

---
